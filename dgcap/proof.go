package dgcap

import (
	"bytes"
	"crypto/ed25519"
	"encoding/binary"
	"fmt"
	"strings"
	"time"

	"github.com/o1egl/paseto/v2"
)

// this is a serial number assigned at creation along with its key pair. This makes creation a little more complex, but accelerates operations on records.
// A dbid combines a serial number assigned by the host with a key pair generated by the client. 40 bytes: 8 bytes LE serial number, 32 bytes public key. This would mean validation always requires a lookup though? The core server will know because of tokens, but auditors can't trust the tokens. It's not clear that auditors want to take the time to validate every record (checking proof) though. What about fastver?

type Dbid uint64

// Databases are integers that are assigned by the host using a host signature.
type Proof struct {
	Version int
	Root    []byte // this must be a root key controlled by the host.
	Db      Dbid
	Grant   []GrantData
}

type GrantData struct {
	To        []byte // public key
	NotBefore uint64
	NotAfter  uint64
	Can       string
	Signature []byte
}

// we have to look up a private key in the key chain.
// we need to look up a proof that allows us to grant the requested capability.
// all proofs start with the root key, but we can cache signatures like the active root->active so we don't have to keep prooving them.

func MarshalGrant(buffer []byte, from []byte, g *GrantData) ([]byte, error) {
	if len(g.Can) > (1024 - 16 - 32) {
		return nil, fmt.Errorf("invalid grant")
	}
	var buf [1024]byte
	copy(buf[:], from)
	copy(buf[32:], g.To)
	binary.LittleEndian.PutUint64(buf[64:], g.NotBefore)
	binary.LittleEndian.PutUint64(buf[72:], g.NotAfter)
	copy(buf[80:], g.Can)
	return buf[:80+len(g.Can)], nil
}
func Verify(root []byte, proof *Proof, cap string) bool {
	var buf [1024]byte
	if !bytes.Equal(proof.Root, root) {
		return false
	}
	cap = cap + "|"
	from := proof.Root
	for _, g := range proof.Grant {
		if !strings.Contains(g.Can, cap) {
			return false
		}
		message, e := MarshalGrant(buf[:], from, &g)
		if e != nil || !ed25519.Verify(from, message, g.Signature) {
			return false
		}
		from = g.To
	}
	return true
}

func Grant(key Keypair, proof *Proof, toPublicKey []byte, can string, dur time.Duration) (*Proof, error) {
	from := proof.Root
	if proof.Grant != nil {
		from = proof.Grant[len(proof.Grant)-1].To
	}
	if !bytes.Equal(key.Public, from) {
		return nil, fmt.Errorf("invalid proof")
	}

	gr := &GrantData{
		To:        toPublicKey,
		NotBefore: uint64(time.Now().Unix()),
		NotAfter:  uint64(time.Now().Add(dur).Unix()),
		Can:       can + "|",
		Signature: nil,
	}

	var buf [1024]byte
	message, e := MarshalGrant(buf[:], from, gr)
	if e != nil {
		return nil, e
	}

	gr.Signature = ed25519.Sign(key.Private, message)
	proof.Grant = append(proof.Grant, *gr)
	return proof, nil
}

// client must send the correct authorization header for the database being written.
func CheckRequest(auth string, secret []byte) ([]byte, error) {

	var token paseto.JSONToken
	var footer string
	err := paseto.Decrypt(auth, secret, &token, &footer)
	if err != nil {
		return nil, err
	}
	return []byte(token.Subject), nil
}

// check the proof and create a token. The token avoids having to check the proof again.
func ProofToken(proof *Proof, secret []byte, proofTime int64) ([]byte, error) {
	now := time.Now()
	exp := now.Add(24 * time.Hour)

	// todo: check that the proof is valid
	// todo: check that the database is valid

	jsonToken := paseto.JSONToken{
		Audience:   "test",
		Issuer:     "test_service",
		Jti:        "123",
		Subject:    "", // dbo.Db,
		IssuedAt:   now,
		Expiration: exp,
		NotBefore:  now,
	}
	// Add custom claim    to the token
	// jsonToken.Set("data", "this is a signed message")
	footer := ""

	// Encrypt data
	token, err := paseto.Encrypt(secret, jsonToken, footer)
	return []byte(token), err
}

func CanRead(token []byte, secret []byte) (Dbid, error) {
	return 0, nil
}

func CanWrite(token []byte, secret []byte) (Dbid, error) {
	return 0, nil
}

// returns the account that the database can be created in
func CanCreate(token []byte, secret []byte) (Dbid, error) {
	return 0, nil
}

// func VerifyAuthHeader(auth string,) (int64, error) {
// 	var token paseto.JSONToken
// 	var footer string
// 	err := paseto.Decrypt(auth, secret, &token, &footer)
// 	if err != nil {
// 		return 0, err
// 	}
// 	dbid, e := strconv.Atoi(token.Subject)
// 	if e != nil {
// 		return 0, e
// 	}
// 	return int64(dbid), nil
// }
