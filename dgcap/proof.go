package dgcap

import (
	"bytes"
	"crypto/ed25519"
	"encoding/binary"
	"encoding/json"
	"fmt"
	"strconv"
	"strings"
	"sync"
	"sync/atomic"
	"time"

	"github.com/o1egl/paseto/v2"
	cuckoo "github.com/seiflotfy/cuckoofilter"
)

// this is a serial number assigned at creation along with its key pair. This makes creation a little more complex, but accelerates operations on records.
// A dbid combines a serial number assigned by the host with a key pair generated by the client. 40 bytes: 8 bytes LE serial number, 32 bytes public key. This would mean validation always requires a lookup though? The core server will know because of tokens, but auditors can't trust the tokens. It's not clear that auditors want to take the time to validate every record (checking proof) though. What about fastver?

type CapDb struct {
	Serial uint64
	root   []byte
	secret sync.Map
	filter *cuckoo.Filter
}

type DbSecret struct {
	Serial uint64
	Secret []byte
}

func (c *CapDb) CurrentSecret() DbSecret {
	return DbSecret{
		Serial: 0,
		Secret: []byte("todo"),
	}
}
func (c *CapDb) GetSecret(sn uint64) []byte {
	return []byte("todo")
}

// we should store top 32 bit, and then use some more logic to make sure this is monotonic.
func (c *CapDb) GetSerialNumber() uint64 {
	o := atomic.AddUint64(&c.Serial, 1)
	return o
}

type Dbid uint64

// Databases are integers that are assigned by the host using a host signature.
type Proof struct {
	Version int
	Root    []byte // this must be a root key controlled by the host.
	Db      Dbid
	Grant   []GrantData
}

// a revoke is a paseto token that can be used to revoke a grant. These are checked by refresh.

type GrantData struct {
	To        []byte // public key
	Serial    uint64 // we can use the serial number to revoke. Would it be more efficient to use NotBefore as a unique lamport clock?
	NotBefore uint64
	NotAfter  uint64
	Can       string
	Signature []byte
}

type Revoke = string // paseto token
type RevokeData struct {
	Serial uint64
	Secret []byte
}

// we have to look up a private key in the key chain.
// we need to look up a proof that allows us to grant the requested capability.
// all proofs start with the root key, but we can cache signatures like the active root->active so we don't have to keep prooving them.

func MarshalGrant(buffer []byte, from []byte, g *GrantData) ([]byte, error) {
	if len(g.Can) > (1024 - 16 - 32) {
		return nil, fmt.Errorf("invalid grant")
	}
	var buf [1024]byte
	copy(buf[:], from)
	copy(buf[32:], g.To)
	binary.LittleEndian.PutUint64(buf[64:], g.NotBefore)
	binary.LittleEndian.PutUint64(buf[72:], g.NotAfter)
	copy(buf[80:], g.Can)
	return buf[:80+len(g.Can)], nil
}
func Verify(root []byte, proof *Proof, cap string) bool {
	var buf [1024]byte
	if !bytes.Equal(proof.Root, root) {
		return false
	}
	cap = cap + "|"
	from := proof.Root
	for _, g := range proof.Grant {
		if !strings.Contains(g.Can, cap) {
			return false
		}
		message, e := MarshalGrant(buf[:], from, &g)
		if e != nil || !ed25519.Verify(from, message, g.Signature) {
			return false
		}
		from = g.To
	}
	return true
}

// return an encrypted token that can be used to revoke the grant.
// the app secret should be a serial number + random bytes so we can rotate it, then regress the key back to that state.
func (c *CapDb) Grant(key Keypair, proof *Proof, toPublicKey []byte, can string, dur time.Duration) (*Proof, Revoke, error) {
	from := proof.Root
	if proof.Grant != nil {
		from = proof.Grant[len(proof.Grant)-1].To
	}
	if !bytes.Equal(key.Public, from) {
		return nil, "", fmt.Errorf("invalid proof")
	}

	sn := c.GetSerialNumber()
	gr := &GrantData{
		To:        toPublicKey,
		NotBefore: uint64(time.Now().Unix()),
		NotAfter:  uint64(time.Now().Add(dur).Unix()),
		Can:       can + "|",
		Signature: nil,
		Serial:    sn,
	}
	// store the serial number
	revoke, e := c.RevokeToken(sn)
	if e != nil {
		return nil, "", e
	}

	var buf [1024]byte
	message, e := MarshalGrant(buf[:], from, gr)
	if e != nil {
		return nil, "", e
	}

	gr.Signature = ed25519.Sign(key.Private, message)
	proof.Grant = append(proof.Grant, *gr)
	return proof, revoke, nil
}

func (c *CapDb) RevokeToken(r uint64) (string, error) {
	var t paseto.JSONToken
	t.Subject = fmt.Sprintf("%d", r)
	t.Audience = "revoke"
	secret := c.CurrentSecret()
	b, e := paseto.Encrypt(secret.Secret, &t, "")
	if e != nil {
		return "", e
	}
	return b, nil
}

// client must send the correct authorization header for the database being written.
// the auth string is serial,paseto
func (c *CapDb) CheckRequest(auth string) ([]byte, error) {

	a := strings.Split(auth, ",")
	sn, e := strconv.Atoi(a[0])
	if e != nil {
		return nil, e
	}
	secret := c.GetSecret(uint64(sn))

	var token paseto.JSONToken
	var footer string
	err := paseto.Decrypt(auth, secret, &token, &footer)
	if err != nil {
		return nil, err
	}
	return []byte(token.Subject), nil
}

// check the proof and create a token and a refresh token. The token avoids having to check the proof again.
// the refresh token provides a cheaper way to check the proof again. (in case of revocation)
func ProofToken(proof *Proof, secret []byte, proofTime int64) ([]byte, []byte, error) {
	now := time.Now()
	exp := now.Add(24 * time.Hour)

	// todo: check that the proof is valid
	// todo: check that the database is valid

	jsonToken := paseto.JSONToken{
		Audience:   "test",
		Issuer:     "test_service",
		Jti:        "123",
		Subject:    "", // dbo.Db,
		IssuedAt:   now,
		Expiration: exp,
		NotBefore:  now,
	}

	refreshToken := paseto.JSONToken{
		Audience: "refresh",
		Subject:  fmt.Sprintf("%d", proof.Db),
	}
	footer2, e := json.Marshal(refreshToken)
	if e != nil {
		return nil, nil, e
	}
	// Add custom claim    to the token
	// jsonToken.Set("data", "this is a signed message")
	footer := ""

	// Encrypt data
	token, err := paseto.Encrypt(secret, jsonToken, footer)
	if err != nil {
		return nil, nil, err
	}
	token2, err := paseto.Encrypt(secret, refreshToken, footer2)
	return []byte(token), []byte(token2), err
}

func CanRead(token []byte, secret []byte) (Dbid, error) {
	return 0, nil
}

func CanWrite(token []byte, secret []byte) (Dbid, error) {
	return 0, nil
}

// returns the account that the database can be created in
func CanCreate(token []byte, secret []byte) (Dbid, error) {
	return 0, nil
}

// func VerifyAuthHeader(auth string,) (int64, error) {
// 	var token paseto.JSONToken
// 	var footer string
// 	err := paseto.Decrypt(auth, secret, &token, &footer)
// 	if err != nil {
// 		return 0, err
// 	}
// 	dbid, e := strconv.Atoi(token.Subject)
// 	if e != nil {
// 		return 0, e
// 	}
// 	return int64(dbid), nil
// }
