package dgcap

import (
	"bytes"
	"crypto/ed25519"
	"crypto/rand"
	"crypto/sha256"
	"encoding/binary"
	"encoding/json"
	"fmt"
	"os"
	"path"
	"strconv"
	"strings"
	"sync"
	"sync/atomic"
	"time"

	"github.com/o1egl/paseto/v2"
	cuckoo "github.com/seiflotfy/cuckoofilter"
)

// this is a serial number assigned at creation along with its key pair. This makes creation a little more complex, but accelerates operations on records.
// A dbid combines a serial number assigned by the host with a key pair generated by the client. 40 bytes: 8 bytes LE serial number, 32 bytes public key. This would mean validation always requires a lookup though? The core server will know because of tokens, but auditors can't trust the tokens. It's not clear that auditors want to take the time to validate every record (checking proof) though. What about fastver?

type CapDbConfig struct {
}
type CapDb struct {
	CapDbConfig
	Serial     uint64
	RootPublic []byte
	Host       Keypair
	secret     sync.Map
	filter     *cuckoo.Filter
	store      CapStore
	HostProof  *Proof
}

// the refresh token contains all keys used to validate the token when it was issue. If none of these have been revoked, then the token is valid.
// take a refresh token and return a new active token and a new refresh token

func NewCapDb(dir string) (*CapDb, error) {
	// there should already be an active host, if not then generate a root and use it to sign a host keypair. Generally you should then delete the root key from any online system.
	var config CapDbConfig
	r := &CapDb{
		secret: sync.Map{},
		filter: cuckoo.NewFilter(1000 * 1000),
		store:  &SimpleCapStore{},
	}

	generateRoot := func() error {
		// create a mnemonic
		mn, e := Bip39()
		if e != nil {
			return e
		}
		os.WriteFile(path.Join(dir, "/root.txt"), []byte(mn), 0644)

		// create a keypair from the mnemonic

		root, e := NewIdentityFromSeed(mn)
		if e != nil {
			return e
		}
		host, e := NewKeypair()
		if e != nil {
			return e
		}
		r.Grant(root, &Proof{
			Root: root.Public,
			Db:   0,
		}, host.Public, "host", 24*time.Hour)

		b, e := json.Marshal(&config)
		if e != nil {
			return e
		}
		os.WriteFile(path.Join(dir, "/index.jsonc"), b, 0644)
		return nil
	}

	b, e := os.ReadFile(path.Join(dir, "/index.jsonc"))
	if e != nil {
		e := generateRoot()
		if e != nil {
			return nil, e
		}
	} else {
		json.Unmarshal(b, &config)
	}
	return r, nil
}

func (c *CapDb) DecryptToken(token string, out *paseto.JSONToken) error {
	s := strings.Split(token, ",")
	sn, e := strconv.Atoi(s[0])
	if e != nil {
		return e
	}
	return paseto.Decrypt(token, c.GetSecret(uint64(sn)), out, nil)
}

type DbSecret struct {
	Serial uint64
	Secret []byte
}

func (c *CapDb) CurrentSecret() DbSecret {
	return DbSecret{
		Serial: 0,
		Secret: []byte("todo"),
	}
}
func (c *CapDb) GetSecret(sn uint64) []byte {
	return []byte("todo")
}

// we should store top 32 bit, and then use some more logic to make sure this is monotonic.
func (c *CapDb) GetSerialNumber() uint64 {
	o := atomic.AddUint64(&c.Serial, 1)
	return o
}

type Dbid uint64

// Databases are integers that are assigned by the host using a host signature.
type Proof struct {
	// these three values are hashed into each grant.
	// note that dbid is only unique in context of the root key.
	Version int
	Root    []byte // this must be a root key controlled by the host.
	Db      Dbid
	// the host grant always uses a db of 0, it can be cached.
	HostGrant GrantData   // active keypair for the host, signed by root.
	Grant     []GrantData // host grants to other keys, eventually to the challenge created by the host.
}

// a revoke is a paseto token that can be used to revoke a grant. These are checked by refresh.

type GrantData struct {
	To         []byte // public key
	Commitment []byte // we can use the hash^-1(Commitment) to revoke.
	NotBefore  uint64
	NotAfter   uint64
	Can        string
	Signature  []byte
}

type Revoke = string // paseto token
type RevokeData struct {
	Serial uint64
	Secret []byte
}

// we have to look up a private key in the key chain.
// we need to look up a proof that allows us to grant the requested capability.
// all proofs start with the root key, but we can cache signatures like the active root->active so we don't have to keep prooving them.

func MarshalGrant(buffer []byte, from []byte, g *GrantData) ([]byte, error) {
	if len(g.Can) > (1024 - 16 - 32) {
		return nil, fmt.Errorf("invalid grant")
	}
	var buf [1024]byte
	copy(buf[:], from)
	copy(buf[32:], g.To)
	binary.LittleEndian.PutUint64(buf[64:], g.NotBefore)
	binary.LittleEndian.PutUint64(buf[72:], g.NotAfter)
	copy(buf[80:], g.Can)
	return buf[:80+len(g.Can)], nil
}
func Verify(root []byte, proof *Proof, cap string) bool {
	var buf [1024]byte
	if !bytes.Equal(proof.Root, root) {
		return false
	}
	cap = cap + "|"
	from := proof.Root
	for _, g := range proof.Grant {
		if !strings.Contains(g.Can, cap) {
			return false
		}
		message, e := MarshalGrant(buf[:], from, &g)
		if e != nil || !ed25519.Verify(from, message, g.Signature) {
			return false
		}
		from = g.To
	}
	return true
}

// return an encrypted token that can be used to revoke the grant.
// the app secret should be a serial number + random bytes so we can rotate it, then regress the key back to that state.
func (c *CapDb) Grant(key Keypair, proof *Proof, toPublicKey []byte, can string, dur time.Duration) (*Proof, Revoke, error) {
	from := proof.Root
	dependsOn := uint64(0)
	if proof.Grant != nil {
		from = proof.Grant[len(proof.Grant)-1].To
		dependsOn = proof.Grant[len(proof.Grant)-1].Serial
	}
	if !bytes.Equal(key.Public, from) {
		return nil, "", fmt.Errorf("invalid proof")
	}

	var revokeKey [32]byte
	_, e := rand.Read(revokeKey[:])
	if e != nil {
		return nil, "", e
	}
	commit := sha256.Sum256(revokeKey[:])

	gr := &GrantData{
		To:         toPublicKey,
		NotBefore:  uint64(time.Now().Unix()),
		NotAfter:   uint64(time.Now().Add(dur).Unix()),
		Can:        can + "|",
		Signature:  nil,
		Commitment: commit[:],
	}
	c.store.AddDependsOn(sn, dependsOn)

	RevokeToken := func(r uint64) (string, error) {
		var t paseto.JSONToken
		t.Subject = fmt.Sprintf("%d", r)
		t.Audience = "revoke"
		secret := c.CurrentSecret()
		b, e := paseto.Encrypt(secret.Secret, &t, "")
		if e != nil {
			return "", e
		}
		return b, nil
	}
	revoke, e := RevokeToken(sn)
	if e != nil {
		return nil, "", e
	}

	var buf [1024]byte
	message, e := MarshalGrant(buf[:], from, gr)
	if e != nil {
		return nil, "", e
	}

	gr.Signature = ed25519.Sign(key.Private, message)
	proof.Grant = append(proof.Grant, *gr)
	return proof, revoke, nil
}

// every grant has a serial number. The revoke identifies this serial number, and then the database identifies all active refresh tokens that depend on this grant. To refresh, we then have to check that our refresh token has not been invalidated. We can do this in memory by checking a cuckoo filter, although its not clear what we can do when the cuckoo filter fills? it might be just as well to use a database indexed by the time that the refresh token will be invalidated as a lamport (unique) clock.
func (c *CapDb) Revoke(token string) error {
	var t paseto.JSONToken
	e := c.DecryptToken(token, &t)
	if e != nil || t.Audience != "revoke" {
		return fmt.Errorf("invalid token")
	}
	serial, e := strconv.Atoi(t.Subject)
	if e != nil {
		return e
	}
	c.store.AddRevoke(uint64(serial), t.Expiration)
	return nil
}

// client must send the correct authorization header for the database being written.
// the auth string is serial,paseto
func (c *CapDb) CheckRequest(token string) ([]byte, error) {
	var t paseto.JSONToken
	e := c.DecryptToken(token, &t)
	if e != nil || t.Audience != "revoke" {
		return nil, fmt.Errorf("invalid token")
	}
	return []byte(t.Subject), nil
}

// check the proof and create a token and a refresh token. The token avoids having to check the proof again.
// the refresh token provides a cheaper way to check the proof again. (in case of revocation)

func (c *CapDb) ProofToken(proof *Proof, proofTime int64) (string, string, error) {
	now := time.Now()
	exp := now.Add(24 * time.Hour)

	secret := c.CurrentSecret()

	// todo: check that the proof is valid
	// todo: check that the database is valid

	jsonToken := paseto.JSONToken{
		Audience:   "test",
		Issuer:     "test_service",
		Jti:        "123",
		Subject:    "", // dbo.Db,
		IssuedAt:   now,
		Expiration: exp,
		NotBefore:  now,
	}

	refreshToken := paseto.JSONToken{
		Audience:   "refresh",
		Subject:    fmt.Sprintf("%d", proof.Db),
		IssuedAt:   now,
		NotBefore:  now,
		Expiration: exp,
	}
	footer2, e := json.Marshal(refreshToken)
	if e != nil {
		return "", "", e
	}
	// Add custom claim    to the token
	// jsonToken.Set("data", "this is a signed message")
	footer := ""

	// Encrypt data
	prefix := fmt.Sprintf("%d,", secret.Serial)
	token, err := paseto.Encrypt(secret.Secret, jsonToken, footer)
	if err != nil {
		return "", "", err
	}
	token2, err := paseto.Encrypt(secret.Secret, refreshToken, footer2)
	return prefix + token, prefix + token2, err
}

func CanRead(token []byte, secret []byte) (Dbid, error) {
	return 0, nil
}

func CanWrite(token []byte, secret []byte) (Dbid, error) {
	return 0, nil
}

// returns the account that the database can be created in
func CanCreate(token []byte, secret []byte) (Dbid, error) {
	return 0, nil
}

// func VerifyAuthHeader(auth string,) (int64, error) {
// 	var token paseto.JSONToken
// 	var footer string
// 	err := paseto.Decrypt(auth, secret, &token, &footer)
// 	if err != nil {
// 		return 0, err
// 	}
// 	dbid, e := strconv.Atoi(token.Subject)
// 	if e != nil {
// 		return 0, e
// 	}
// 	return int64(dbid), nil
// }
