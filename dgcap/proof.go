package dgcap

import (
	"bytes"
	"crypto/ed25519"
	"encoding/binary"
	"fmt"
	"strings"
	"sync"
	"sync/atomic"
	"time"

	"github.com/o1egl/paseto/v2"
	cuckoo "github.com/seiflotfy/cuckoofilter"
	"golang.org/x/exp/rand"
)

// this is a serial number assigned at creation along with its key pair. This makes creation a little more complex, but accelerates operations on records.
// A dbid combines a serial number assigned by the host with a key pair generated by the client. 40 bytes: 8 bytes LE serial number, 32 bytes public key. This would mean validation always requires a lookup though? The core server will know because of tokens, but auditors can't trust the tokens. It's not clear that auditors want to take the time to validate every record (checking proof) though. What about fastver?

type CapDb struct {
	Serial uint64
	root   []byte
	secret sync.Map
	filter *cuckoo.Filter
}

// we should store top 32 bit, and then use some more logic to make sure this is monotonic.
func (c *CapDb) GetSerialNumber() uint64 {
	o := atomic.AddUint64(&c.Serial, 1)
	return o
}

type Dbid uint64

// Databases are integers that are assigned by the host using a host signature.
type Proof struct {
	Version int
	Root    []byte // this must be a root key controlled by the host.
	Db      Dbid
	Grant   []GrantData
}

type GrantData struct {
	To        []byte // public key
	Serial    uint64 // we can use the serial number to revoke. Would it be more efficient to use NotBefore as a unique lamport clock?
	NotBefore uint64
	NotAfter  uint64
	Can       string
	Signature []byte
}

type Revoke = []byte
type RevokeData struct {
	Serial uint64
	Secret []byte
}

// we have to look up a private key in the key chain.
// we need to look up a proof that allows us to grant the requested capability.
// all proofs start with the root key, but we can cache signatures like the active root->active so we don't have to keep prooving them.

func MarshalGrant(buffer []byte, from []byte, g *GrantData) ([]byte, error) {
	if len(g.Can) > (1024 - 16 - 32) {
		return nil, fmt.Errorf("invalid grant")
	}
	var buf [1024]byte
	copy(buf[:], from)
	copy(buf[32:], g.To)
	binary.LittleEndian.PutUint64(buf[64:], g.NotBefore)
	binary.LittleEndian.PutUint64(buf[72:], g.NotAfter)
	copy(buf[80:], g.Can)
	return buf[:80+len(g.Can)], nil
}
func Verify(root []byte, proof *Proof, cap string) bool {
	var buf [1024]byte
	if !bytes.Equal(proof.Root, root) {
		return false
	}
	cap = cap + "|"
	from := proof.Root
	for _, g := range proof.Grant {
		if !strings.Contains(g.Can, cap) {
			return false
		}
		message, e := MarshalGrant(buf[:], from, &g)
		if e != nil || !ed25519.Verify(from, message, g.Signature) {
			return false
		}
		from = g.To
	}
	return true
}

func (c *CapDb) Grant(key Keypair, proof *Proof, toPublicKey []byte, can string, dur time.Duration) (*Proof, Revoke, error) {
	from := proof.Root
	if proof.Grant != nil {
		from = proof.Grant[len(proof.Grant)-1].To
	}
	if !bytes.Equal(key.Public, from) {
		return nil, nil, fmt.Errorf("invalid proof")
	}

	gr := &GrantData{
		To:        toPublicKey,
		NotBefore: uint64(time.Now().Unix()),
		NotAfter:  uint64(time.Now().Add(dur).Unix()),
		Can:       can + "|",
		Signature: nil,
		Serial:    c.GetSerialNumber(),
	}
	// store the serial number
	revoke := make([]byte, 16)
	rand.Read(revoke)

	var buf [1024]byte
	message, e := MarshalGrant(buf[:], from, gr)
	if e != nil {
		return nil, nil, e
	}

	gr.Signature = ed25519.Sign(key.Private, message)
	proof.Grant = append(proof.Grant, *gr)
	return proof, revoke, nil
}

// client must send the correct authorization header for the database being written.
func CheckRequest(auth string, secret []byte) ([]byte, error) {

	var token paseto.JSONToken
	var footer string
	err := paseto.Decrypt(auth, secret, &token, &footer)
	if err != nil {
		return nil, err
	}
	return []byte(token.Subject), nil
}

// check the proof and create a token. The token avoids having to check the proof again.
func ProofToken(proof *Proof, secret []byte, proofTime int64) ([]byte, error) {
	now := time.Now()
	exp := now.Add(24 * time.Hour)

	// todo: check that the proof is valid
	// todo: check that the database is valid

	jsonToken := paseto.JSONToken{
		Audience:   "test",
		Issuer:     "test_service",
		Jti:        "123",
		Subject:    "", // dbo.Db,
		IssuedAt:   now,
		Expiration: exp,
		NotBefore:  now,
	}
	// Add custom claim    to the token
	// jsonToken.Set("data", "this is a signed message")
	footer := ""

	// Encrypt data
	token, err := paseto.Encrypt(secret, jsonToken, footer)
	return []byte(token), err
}

func CanRead(token []byte, secret []byte) (Dbid, error) {
	return 0, nil
}

func CanWrite(token []byte, secret []byte) (Dbid, error) {
	return 0, nil
}

// returns the account that the database can be created in
func CanCreate(token []byte, secret []byte) (Dbid, error) {
	return 0, nil
}

// func VerifyAuthHeader(auth string,) (int64, error) {
// 	var token paseto.JSONToken
// 	var footer string
// 	err := paseto.Decrypt(auth, secret, &token, &footer)
// 	if err != nil {
// 		return 0, err
// 	}
// 	dbid, e := strconv.Atoi(token.Subject)
// 	if e != nil {
// 		return 0, e
// 	}
// 	return int64(dbid), nil
// }
