package dgcap

import (
	"crypto/ed25519"
	"crypto/rand"
	"crypto/sha256"
	"encoding/binary"
	"encoding/json"
	"fmt"
	"os"
	"path"
	"strconv"
	"strings"
	"sync"
	"sync/atomic"
	"time"

	"github.com/o1egl/paseto/v2"
	cuckoo "github.com/seiflotfy/cuckoofilter"
)

// this is a serial number assigned at creation along with its key pair. This makes creation a little more complex, but accelerates operations on records.
// A dbid combines a serial number assigned by the host with a key pair generated by the client. 40 bytes: 8 bytes LE serial number, 32 bytes public key. This would mean validation always requires a lookup though? The core server will know because of tokens, but auditors can't trust the tokens. It's not clear that auditors want to take the time to validate every record (checking proof) though. What about fastver?

type CapDbConfig struct {
}
type CapDb struct {
	CapDbConfig
	Serial     uint64
	RootPublic []byte
	Host       Keypair
	secret     sync.Map
	filter     *cuckoo.Filter
	store      CapStore
	HostProof  *Proof
}

// the refresh token contains all keys used to validate the token when it was issue. If none of these have been revoked, then the token is valid.
// take a refresh token and return a new active token and a new refresh token

func NewCapDb(dir string) (*CapDb, error) {
	// there should already be an active host, if not then generate a root and use it to sign a host keypair. Generally you should then delete the root key from any online system.
	var config CapDbConfig
	r := &CapDb{
		secret: sync.Map{},
		filter: cuckoo.NewFilter(1000 * 1000),
		store:  &SimpleCapStore{},
	}

	// generate a root keypair and a host keypair.
	generateRoot := func() error {
		// create a mnemonic
		mn, e := Bip39()
		if e != nil {
			return e
		}
		os.WriteFile(path.Join(dir, "/root.txt"), []byte(mn), 0644)

		// create a keypair from the mnemonic

		root, e := NewIdentityFromSeed(mn)
		if e != nil {
			return e
		}
		host, e := NewKeypair()
		host.WriteFile(path.Join(dir, "/host.key"))
		if e != nil {
			return e
		}
		var commit [32]byte
		_, e = rand.Read(commit[:])
		if e != nil {
			return e
		}
		c2 := sha256.Sum256(commit[:])
		gr := GrantData{
			To:         host.Public,
			Commitment: c2[:],
			NotBefore:  uint64(time.Now().Unix()),
			NotAfter:   uint64(time.Now().Add(365 * 24 * time.Hour).Unix()),
			Can:        "host|",
			Signature:  []byte{},
		}
		pr := &Proof{
			Version: 0,
			Root:    root.Public,
			Grant:   []GrantData{gr},
		}

		b, e := json.Marshal(&config)
		if e != nil {
			return e
		}
		os.WriteFile(path.Join(dir, "/index.jsonc"), b, 0644)
		return nil
	}

	b, e := os.ReadFile(path.Join(dir, "/index.jsonc"))
	if e != nil {
		e := generateRoot()
		if e != nil {
			return nil, e
		}
	} else {
		json.Unmarshal(b, &config)
	}
	return r, nil
}

func (c *CapDb) DecryptToken(token string, out *paseto.JSONToken) error {
	s := strings.Split(token, ",")
	sn, e := strconv.Atoi(s[0])
	if e != nil {
		return e
	}
	return paseto.Decrypt(token, c.GetSecret(uint64(sn)), out, nil)
}

type DbSecret struct {
	Serial uint64
	Secret []byte
}

func (c *CapDb) CurrentSecret() DbSecret {
	return DbSecret{
		Serial: 0,
		Secret: []byte("todo"),
	}
}
func (c *CapDb) GetSecret(sn uint64) []byte {
	return []byte("todo")
}

// we should store top 32 bit, and then use some more logic to make sure this is monotonic.
func (c *CapDb) GetSerialNumber() uint64 {
	o := atomic.AddUint64(&c.Serial, 1)
	return o
}

type Dbid uint64

// Databases are integers that are assigned by the host using a host signature.
type Proof struct {
	// these three values are hashed into each grant.
	// note that dbid is only unique in context of the root key.
	Version int
	Root    []byte // this must be a root key controlled by the host.
	// the host grant always uses a db of 0, so it can be cached.
	Grant []GrantData // host grants to other keys, eventually to the challenge created by the host.
}

// a revoke is a paseto token that can be used to revoke a grant. These are checked by refresh.

type GrantData struct {
	To         []byte // public key
	Commitment []byte // we can use the hash^-1(Commitment) to revoke.
	NotBefore  uint64
	NotAfter   uint64
	Can        string // db db schema schema write
	Signature  []byte
}

// type Revoke = string // paseto token
// type RevokeData struct {
// 	Serial uint64
// 	Secret []byte
// }

// we have to look up a private key in the key chain.
// we need to look up a proof that allows us to grant the requested capability.
// all proofs start with the root key, but we can cache signatures like the active root->active so we don't have to keep prooving them.

func MarshalGrant(buffer []byte, from []byte, g *GrantData) ([]byte, error) {
	if len(g.Can) > (1024 - 16 - 32) {
		return nil, fmt.Errorf("invalid grant")
	}
	var buf [1024]byte
	copy(buf[:], from)
	copy(buf[32:], g.To)
	binary.LittleEndian.PutUint64(buf[64:], g.NotBefore)
	binary.LittleEndian.PutUint64(buf[72:], g.NotAfter)
	copy(buf[80:], g.Can)
	return buf[:80+len(g.Can)], nil
}

// what caps do we need? do we need verify a range of database/schema? a prefix? can I check every assertion at each step that its restricting? Can I return the final cap set? does a return token represent all the capability of the proof, or only the requested parts? We can always modify the proof to reduce the capability.

type CapSet struct {
}

// convert to a string to stash in a token.
func (c *CapSet) ToString() {

}

func (c *CapDb) Verify(proof *Proof) (*CapSet, error) {
	var r CapSet

	var buf [1024]byte

	cap = cap + "|"
	from := proof.Root
	for _, g := range proof.Grant {
		if !strings.Contains(g.Can, cap) {
			return false
		}
		message, e := MarshalGrant(buf[:], from, &g)
		if e != nil || !ed25519.Verify(from, message, g.Signature) {
			return false
		}
		from = g.To
	}
	return &r, nil
}

func Grant(key Keypair, proof *Proof, commit []byte, toPublicKey []byte, can string, dur time.Duration) (*Proof, error) {
	gr := &GrantData{
		To:         toPublicKey,
		NotBefore:  uint64(time.Now().Unix()),
		NotAfter:   uint64(time.Now().Add(dur).Unix()),
		Can:        can + "|",
		Signature:  nil,
		Commitment: commit,
	}

	var buf [1024]byte
	message, e := MarshalGrant(buf[:], key.Public, gr)
	if e != nil {
		return nil, e
	}

	gr.Signature = ed25519.Sign(key.Private, message)
	proof.Grant = append(proof.Grant, *gr)
	return proof, nil
}

// client must send the correct authorization header for the database being written.
// the auth string is serial,paseto
func (c *CapDb) CheckRequest(token string) ([]byte, error) {
	var t paseto.JSONToken
	e := c.DecryptToken(token, &t)
	if e != nil || t.Audience != "revoke" {
		return nil, fmt.Errorf("invalid token")
	}
	return []byte(t.Subject), nil
}

// a serial number with revoke database allows us to work without a refresh token. We can do a simple database check on the expired token (look up by serial number) to see if we can refresh it or not.

func (c *CapDb) ProofToken(proof *Proof, proofTime int64) (string, error) {
	now := time.Now()
	exp := now.Add(24 * time.Hour)

	secret := c.CurrentSecret()

	// todo: check that the proof is valid
	// todo: check that the database is valid

	//c.store.AddDependsOn(secret.Serial, exp)

	jsonToken := paseto.JSONToken{
		Audience:   "test",
		Issuer:     "test_service",
		Jti:        "123",
		Subject:    "", // dbo.Db,
		IssuedAt:   now,
		Expiration: exp,
		NotBefore:  now,
	}

	// Add custom claim    to the token
	// jsonToken.Set("data", "this is a signed message")
	footer := ""

	// Encrypt data
	prefix := fmt.Sprintf("%d,", secret.Serial)
	token, err := paseto.Encrypt(secret.Secret, jsonToken, footer)
	if err != nil {
		return "", err
	}
	token2, err := paseto.Encrypt(secret.Secret, refreshToken, footer2)
	return prefix + token, prefix + token2, err
}

// func VerifyAuthHeader(auth string,) (int64, error) {
// 	var token paseto.JSONToken
// 	var footer string
// 	err := paseto.Decrypt(auth, secret, &token, &footer)
// 	if err != nil {
// 		return 0, err
// 	}
// 	dbid, e := strconv.Atoi(token.Subject)
// 	if e != nil {
// 		return 0, e
// 	}
// 	return int64(dbid), nil
// }
